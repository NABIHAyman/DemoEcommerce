<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Login</title>
</head>
<body>

<h1>E-commerce Login</h1>

{#
Gestion des erreurs d'authentification native de Symfony.
Si le pare-feu rejette les identifiants lors du POST, la variable 'error' est injectée dans la vue.
Le filtre '|trans' utilise le dictionnaire 'security' de Symfony pour afficher un message propre
(ex: "Invalid credentials.") sans révéler de détails techniques à l'utilisateur.
#}
{% if error %}
    <div style="color: red;">
        {{ error.messageKey|trans(error.messageData, 'security') }}
    </div>
{% endif %}

{#
Lecture du FlashBag de la session HTTP (app.flashes).
C'est ici qu'apparaîtront les messages de succès verts ("Your password has been successfully reset")
ou les erreurs rouges envoyés par notre ResetPasswordController juste avant la redirection (pattern PRG).
#}
{% for message in app.flashes('success') %}
    <div style="color: green;">{{ message }}</div>
{% endfor %}
{% for message in app.flashes('error') %}
    <div style="color: red;">{{ message }}</div>
{% endfor %}

{#
Le formulaire n'a pas d'attribut 'action'. Il soumet donc en POST sur la route actuelle (/login).
C'est le composant "form_login" défini dans notre security.yaml qui va intercepter magiquement
cette requête HTTP POST avant même qu'elle n'atteigne le AuthenticationController.
#}
<form method="post">

    <div>
        <label for="username">Email address</label>
        {#
        L'attribut name="_username" est la clé exacte que le pare-feu Symfony va chercher.
        L'injection de 'last_username' (passé par le contrôleur) est une best practice d'UX :
        elle évite à l'utilisateur de devoir retaper son email s'il s'est trompé de mot de passe.
        #}
        <input type="email" value="{{ last_username }}" name="_username" id="username" autocomplete="email" required autofocus>
    </div>

    <div>
        <label for="password">Password</label>
        {# L'attribut name="_password" est la seconde clé obligatoire pour le pare-feu. #}
        <input type="password" name="_password" id="password" autocomplete="current-password" required>
    </div>

    {#
    CRUCIAL - Jeton CSRF (Cross-Site Request Forgery).
    Cette fonction Twig génère un token cryptographique unique lié à la session de l'utilisateur.
    Il empêche un site malveillant tiers de forger une fausse requête POST de connexion à l'insu de l'utilisateur.
    L'identifiant 'authenticate' est le nom de l'intention attendue par défaut par Symfony.
    #}
    <input type="hidden" name="_csrf_token" value="{{ csrf_token('authenticate') }}">

    <button type="submit">Sign in</button>

    <a href="{{ path('app_register') }}" style="display: block; text-align: center; margin-top: 15px;">Don't have an account? Sign up</a>

    <div style="margin-top: 10px;">
        {#
        Génération dynamique de l'URL absolue/relative via la fonction path() de Twig.
        On utilise la nomenclature anglaise définie dans le contrôleur (app_forgot_password).
        Ceci garantit que si l'on modifie l'URL physique dans l'attribut #[Route], ce lien ne cassera pas.
        #}
        <a href="{{ path('app_forgot_password') }}">Forgot password?</a>
    </div>

</form>

</body>
</html>
